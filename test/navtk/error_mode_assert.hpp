#pragma once

#include <forward_list>
#include <memory>
#include <ostream>
#include <regex>
#include <string>
#include <type_traits>

#include <gtest/gtest.h>
#include <spdlog_assert.hpp>

#include <navtk/errors.hpp>
#include <navtk/utils/human_readable.hpp>

namespace testing {
namespace detail {


// SFINAE struct for "things that have a .what() method which returns a string."
DECLARE_SFINAE_BY_EXPR_VALIDITY(HasReadableWhatMethod, std::string{std::declval<T>().what()});

// SFINAE struct for "types that have an operator<<(ostream&, T) defined"
DECLARE_SFINAE_BY_EXPR_VALIDITY(IsPrintable, std::declval<std::ostream&>() << std::declval<T>());

// SFINAE type provided by fmt for things that have an explicit formatter declared
template <typename T>
using SupportedByFmt = fmt::is_formattable<T, ::fmt::format_context>;

// SFINAE type for things fmt can print, which is anything that has a formatter plus anything
// that has the ostream<< operator.
template <typename T>
struct IsFormattable {
	static constexpr bool value = SupportedByFmt<T>::value || IsPrintable<T>::value;
};

DECLARE_SFINAE_ENABLE_IF(IsFormattable);


// Memory locations for default-constructed values generated by
// ExpressionThrowTester::expect_exception. Since the macro action may be a reference type, just
// returning a default constructed value without giving it a memory address somewhere as well will
// cause use-after-free/use-after-return errors.
typedef std::unique_ptr<void, std::function<void(void*)>> OpaquePtr;
std::forward_list<OpaquePtr>& get_pins();

}  // namespace detail

// A convenience alias for "the return value of the given lambda."
template <typename Func>
using ReturnOf = decltype(std::declval<Func>()());

// A test harness that executes a lambda and examines its behavior, checking for thrown exceptions,
// logs, or silence, and reporting those results to gtest.
//
// It is intended that this class be instantiated/invoked via one of the macros below, which will
// use brace-init to fill in its values.
template <typename exc>
class ExpressionThrowTester {
public:
	std::string action;  //!< String version of the code being tested
	// TODO: Replace this with std::string to get rid of the bare pointer whenever gtest gets
	// upgraded to support std::strings itself
	const char* file;     //!< File of invoking test (provided by __FILE__ macro)
	int line;             //!< Line number of invoking test (provided by __LINE__ macro)
	bool fatal;           //!< Whether test failures are fatal (ASSERT_*) or not (EXPECT_*)
	std::string pattern;  //!< A string to compare exceptions/logs against

	/**
	 * Whether to deliberately break the global error mode to make sure the function under test is
	 * honoring a mode parameter rather than the global mode.
	 */
	bool param_mode;

	std::regex re;  //!< #pattern compiled as a regex

	ExpressionThrowTester(const std::string& action,
	                      const char* file,
	                      int line,
	                      bool fatal,
	                      const std::string& pattern,
	                      bool param_mode = false)
	    : action(action),
	      file(file),
	      line(line),
	      fatal(fatal),
	      pattern(pattern),
	      param_mode(param_mode),
	      re(pattern, std::regex::icase) {}

	// Call the given lambda and forward its return value, but fail the test if it doesn't throw an
	// exception of type exc that matches the pattern.
	template <typename Func>
	ReturnOf<Func> expect_exception(Func&& func) {
		{
			LogCatcher catcher(file, line, SPDLOG_LEVEL_OFF, action, pattern);
			try {
				return static_cast<ReturnOf<Func>>(
				    raise_didnt_throw<ReturnOf<Func>>(call_func(std::forward<Func>(func))));
			} catch (const AssertionException&) {
				throw;
			} catch (const exc& exception) {
				auto failure = make_failure();
				if (!pattern.empty() && !check_exception_matches_pattern(failure, exception))
					fail(failure);
				catcher.detach_and_send_result(fatal);
			}
		}
		return static_cast<ReturnOf<Func>>(alloc_and_return<ReturnOf<Func>>());
	}

	// Call the given lambda and forward its return value, but fail the test if it emits any log
	// messages.
	template <typename Func>
	ReturnOf<Func> expect_silence(Func&& func) {
		return LogCatcher(file, line, SPDLOG_ASSERT_NO_LOG, action, pattern)
		    .pass_through_and_assert(call_func(std::forward<Func>(func)), fatal);
	}

	// Call the given lambda and forward its return value, but fail the test if it doesn't emit a
	// log message matching the expected pattern.
	template <typename Func>
	ReturnOf<Func> expect_log(Func&& func) {
		LogCatcher catcher(file, line, SPDLOG_LEVEL_OFF, action, pattern);
		return catcher.pass_through_and_assert(call_func(std::forward<Func>(func)), fatal);
	}

	// Equivalent to whichever of expect_exception, expect_silence or expect_log is indicated by
	// the current global error mode.
	template <typename Func>
	ReturnOf<Func> expect_honors_mode(Func&& func) {
		switch (::navtk::get_global_error_mode()) {
		case ::navtk::ErrorMode::OFF:
			return expect_silence(std::forward<Func>(func));
		case ::navtk::ErrorMode::LOG:
			return expect_log(std::forward<Func>(func));
		case ::navtk::ErrorMode::DIE:
			return expect_exception(std::forward<Func>(func));
		default:
			throw AssertionException(
			    TestPartResult(TestPartResult::kFatalFailure, file, line, "invalid error mode."));
		}
	}

	// Call the given lambda twice, once with ErrorMode::DIE (and expect and exception) and once
	// with ErrorMode::LOG (and expect a log message, followed by undefined behavior).
	//
	// The log message is caught using stack-unrolling trickery to prevent subsequent code (after
	// the code that emits the log) from running. This avoids undefined behavior in tests.
	template <typename Func>
	void expect_ub_or_die(Func&& func) {
		{
			auto safe_call_func = [&]() -> VoidWorkaround {
				func();
				return {};
			};
			::navtk::ErrorModeLock guard{::navtk::ErrorMode::DIE};
			expect_exception(safe_call_func);
		}
		expect_ub_after_log(func);
	}

	// Call the given lambda and expect it to emit a log, but once the expected log has been
	// received, terminate the function call to prevent subsequent undefined-behavior code from
	// running.
	//
	// The stack-unrolling technique (c++ exception, rethrown from an spdlog exception-handling
	// callback) works just fine everywhere but ARM with -fsanitize=address, which gets confused and
	// leaves stack redzone bytes behind (causing subsequent code to die with a bogus
	// stack-use-after-return), so when compiled under arm+asan, we suppress asan for this function.
	//
	// An alternative solution to this problem would be to fork the process before the second
	// temporary scope and use the exit status of the subprocess to determine success. The downsides
	// to doing it that way are memory usage, code complexity, and portability (since Windows can't
	// fork()). A proof-of-concept candidate branch has been pushed as archive/use_forks_to_test_ub,
	// which passes CI, but it's incomplete -- it ignores the return value of waitpid() and never
	// checks WIFEXITED().
	//
	// It is believed that this is an already-fixed bug in ASAN -- a symptom of the age of the
	// arm+asan userland -- and as such can be removed whenever we upgrade our cross build
	template <typename Func>
	void expect_ub_after_log(Func&& func) {
		::navtk::ErrorModeLock guard{::navtk::ErrorMode::LOG};
		LogCatcher catcher(file, line, SPDLOG_LEVEL_OFF, action, pattern, true);
		try {
			func();
		} catch (const LogCatcher::Aborting&) {
		}
		catcher.detach_and_send_result(fatal);
	}

private:
	// Call the function, optionally (in param_mode) with a different global error mode set.
	template <typename Func>
	ReturnOf<Func> call_func(Func&& func) {
		::navtk::ErrorModeLock guard{param_mode ? some_other_mode()
		                                        : ::navtk::get_global_error_mode()};
		// Using VoidWorkaround again (when it's already in the EXPRESSION_THROW_TESTER_ macro)
		// causes the compiler to return a more helpful error message in the case where the action
		// parameter doesn't compile. When that happens, the compiler tries to continue assuming the
		// action lambda returns void, which causes tons of compiler errors within this class that
		// have nothing to do with the actual problem.
		return static_cast<ReturnOf<Func>>(func());
	}

	// Return some error mode other than the current global one.
	::navtk::ErrorMode some_other_mode() {
		return (::navtk::get_global_error_mode() == ::navtk::ErrorMode::DIE)
		           ? ::navtk::ErrorMode::OFF
		           : ::navtk::ErrorMode::DIE;
	}

	// Populate a generic gtest AssertionFailure(), used as the base of most of the possible test
	// failure messages generated by this class.
	AssertionResult make_failure() {
		auto out = AssertionFailure() << "Expected { " << action << " } to throw "
		                              << ::navtk::utils::identify_type<exc>();
		if (!pattern.empty()) out << " matching /" << pattern << "/i";
		return out;
	}

	// make_failure() but also include details about the given value `t`, which was returned by the
	// lambda passed into one of the expect_* functions
	template <typename T>
	AssertionResult make_failure_with_value(const T& t) {
		return make_failure() << ", but it returned " << describe_return_value(t) << ".";
	}

	// Propagate the given AssertionResult (really AssertionFailure, but that's not a type) to
	// gtest. If fatal or force_fatal are true, abort the remainder of the current test.
	void fail(const AssertionResult& failure) { result_to_message(failure, fatal, file, line); }

	// Send gtest a failure message about the value `t`, but return it anyway (doing this in a
	// template function with universal references is trickery to get all the `auto`s of the
	// `expect_*` functions to have the same type).
	template <typename T>
	auto raise_didnt_throw(T&& t) -> decltype(t) {
		fail(make_failure_with_value(t));
		return static_cast<decltype(t)>(t);
	}

	// Uses fmt::format to convert the value to a string
	template <typename T, detail::EnableIfIsFormattable<T, true> = nullptr>
	std::string describe_return_value(const T& value) {
		return fmt::format("instance of `{}` at memory address {:#0x} with value `{}`",
		                   navtk::utils::identify_type<T>(),
		                   reinterpret_cast<intptr_t>(&value),
		                   value);
	}

	// Fallback value description for values that aren't compatible with fmt::format
	template <typename T, detail::EnableIfIsFormattable<T, false> = nullptr>
	std::string describe_return_value(const T& value) {
		return fmt::format("instance of `{}` at memory address {:#0x}",
		                   navtk::utils::identify_type<T>(),
		                   reinterpret_cast<intptr_t>(&value));
	}

	// Special-case overload for the VoidWorkaround type used to allow void-expressions to be the
	// test action.
	std::string describe_return_value(const VoidWorkaround&) { return "void"; }

	// Regex-based tester that makes sure exception.what() =~ /pattern/
	template <typename exc_ = exc, detail::EnableIfHasReadableWhatMethod<exc_, true> = nullptr>
	bool check_exception_matches_pattern(AssertionResult& out, const exc& exception) {
		std::string what = exception.what();
		out << ", but the exception message was \"" << what << "\".";
		return std::regex_search(what, re);
	}

	// Fallback for exceptions that don't have a string-compatible .what() method.
	template <typename exc_ = exc, detail::EnableIfHasReadableWhatMethod<exc_, false> = nullptr>
	bool check_exception_matches_pattern(AssertionResult& out, const exc&) {
		// We're supposed to be testing for a pattern, but we can't, so fail the unit test.
		out << ", but the exception class does not have a .what() method.";
		return false;
	}

	// Create a default-constructed instance of T and stick it somewhere with a memory address so
	// that a reference to it can be returned.
	template <typename T, typename R = std::remove_reference_t<T>>
	typename std::enable_if<std::is_default_constructible<R>::value, R&>::type alloc_and_return() {
		R* raw_ptr = new R{};
		// To guarantee we don't leak this memory location, save it as a `unique_ptr` with a custom
		// deleter that will use the correct destructor.
		detail::get_pins().emplace_front(raw_ptr, [=](void*) { delete raw_ptr; });
		return *raw_ptr;
	}

	// If we can't default-construct T, abort the test.
	template <typename T, typename R = std::remove_reference_t<T>>
	typename std::enable_if<!std::is_default_constructible<R>::value, R&>::type alloc_and_return() {
		spdlog::warn(
		    "The action `{}` on {}:{} successfully threw an instance of {}, but the test is being "
		    "aborted early because the action's return type `{}` cannot be default-constructed. "
		    "Consider explicitly casting the action to (void).",
		    action,
		    file,
		    line,
		    navtk::utils::identify_type<exc>(),
		    navtk::utils::identify_type<T>());
		throw AssertionException(
		    TestPartResult(TestPartResult::kSuccess, file, line, "caught the desired exception"));
	}
};

}  // namespace testing

#define VA_FIRST_(A, ...) A
#define VA_SECOND_(A, B, ...) B

#define EXPRESSION_THROW_TESTER_(action, verb, exc_class, ...)                             \
	(::testing::ExpressionThrowTester<exc_class>(#action, __FILE__, __LINE__, __VA_ARGS__) \
	     .expect_##verb(                                                                   \
	         [&]() -> decltype(auto) { return ((action), ::testing::VoidWorkaround{}); }))

// Read the global error mode, then run the given action. If the global mode is ErrorMode::OFF,
// expect no logs to be emitted. If it's ErrorMode::LOG, expect a log matching the given message. If
// it's ErrorMode::DIE, expect an exception of type exc_class to be emitted.
//
// This macro can be used as an expression if the underlying action returns a value. If the action
// throws the expected exception, the value is default-constructed. If default-constructing an
// object of the result type is a compiler error, the test will be aborted.
//
// For maximum testiness, consider using this macro within an ERROR_MODE_SENSITIVE_TEST.
#define EXPECT_HONORS_MODE_EX(action, message, exc_class) \
	EXPRESSION_THROW_TESTER_(action, honors_mode, exc_class, false, message)

// Read the global error mode, then run the given action. If the global mode is ErrorMode::OFF,
// expect no logs to be emitted. If it's ErrorMode::LOG, expect a log matching the given message. If
// it's ErrorMode::DIE, expect an exception of type ::navtk::DefaultLogOrThrowException to be
// emitted.
//
// This macro can be used as an expression if the underlying action returns a value. If the action
// throws the expected exception, the value is default-constructed. If default-constructing an
// object of the result type is a compiler error, the test will be aborted.
//
// For maximum testiness, consider using this macro within an ERROR_MODE_SENSITIVE_TEST.
#define EXPECT_HONORS_MODE(action, message) \
	EXPECT_HONORS_MODE_EX(action, message, ::navtk::DefaultLogOrThrowException)

// Change the global error mode, then run the given action, making sure the action behaves according
// to the error mode before it was changed. For example, if the global error mode is ErrorMode::DIE,
// this will set ErrorMode::OFF but still expect the action to throw an exception.
//
// Use this inside an ERROR_MODE_SENSITIVE_TEST with an action written in terms of the `mode`
// instance variable to make sure a function that takes a mode parameter honors its parameter rather
// than the global mode.
#define EXPECT_HONORS_MODE_PARAM_EX(action, message, exc_class) \
	EXPRESSION_THROW_TESTER_(action, honors_mode, exc_class, false, message, true)

// Change the global error mode, then run the given action, making sure the action behaves according
// to the error mode before it was changed. For example, if the global error mode is ErrorMode::DIE,
// this will set ErrorMode::OFF but still expect the action to throw an exception.
//
// Use this inside an ERROR_MODE_SENSITIVE_TEST with an action written in terms of the `mode`
// instance variable to make sure a function that takes a mode parameter honors its parameter rather
// than the global mode.
#define EXPECT_HONORS_MODE_PARAM(action, message) \
	EXPECT_HONORS_MODE_PARAM_EX(action, message, ::navtk::DefaultLogOrThrowException)

// Change the global error mode, then run the given action, making sure the action behaves according
// to the error mode before it was changed. For example, if the global error mode is ErrorMode::DIE,
// this will set ErrorMode::OFF but still expect the action to throw an exception.
//
// Use this inside an ERROR_MODE_SENSITIVE_TEST with an action written in terms of the `mode`
// instance variable to make sure a function that takes a mode parameter honors its parameter rather
// than the global mode.
#define ASSERT_HONORS_MODE_PARAM_EX(action, message, exc_class) \
	EXPRESSION_THROW_TESTER_(action, honors_mode, exc_class, false, message, true)

// Change the global error mode, then run the given action, making sure the action behaves according
// to the error mode before it was changed. For example, if the global error mode is ErrorMode::DIE,
// this will set ErrorMode::OFF but still expect the action to throw an exception.
//
// Use this inside an ERROR_MODE_SENSITIVE_TEST with an action written in terms of the `mode`
// instance variable to make sure a function that takes a mode parameter honors its parameter rather
// than the global mode.
#define ASSERT_HONORS_MODE_PARAM(action, message) \
	ASSERT_HONORS_MODE_PARAM_EX(action, message, ::navtk::DefaultLogOrThrowException)

// Read the global error mode, then run the given action. If the global mode is ErrorMode::OFF,
// assert no logs to be emitted. If it's ErrorMode::LOG, assert a log matching the given message. If
// it's ErrorMode::DIE, assert an exception of type exc_class to be emitted.
//
// This macro can be used as an expression if the underlying action returns a value. If the action
// throws the expected exception, the value is default-constructed. If default-constructing an
// object of the result type is a compiler error, the test will be aborted.
//
// For maximum testiness, consider using this macro within an ERROR_MODE_SENSITIVE_TEST.
#define ASSERT_HONORS_MODE_EX(action, message, exc_class) \
	EXPRESSION_THROW_TESTER_(action, honors_mode, exc_class, false, message)

// Read the global error mode, then run the given action. If the global mode is ErrorMode::OFF,
// assert no logs to be emitted. If it's ErrorMode::LOG, assert a log matching the given message. If
// it's ErrorMode::DIE, assert an exception of type exc_class to be emitted.
//
// This macro can be used as an expression if the underlying action returns a value. If the action
// throws the expected exception, the value is default-constructed. If default-constructing an
// object of the result type is a compiler error, the test will be aborted.
//
// For maximum testiness, consider using this macro within an ERROR_MODE_SENSITIVE_TEST.
#define ASSERT_HONORS_MODE(action, message) \
	ASSERT_HONORS_MODE_EX(action, message, ::navtk::DefaultLogOrThrowException)

// Macro returning the name of the class generated by an ERROR_MODE_SENSITIVE_TEST macro call to
// contain its test body. You may need to declare this name a `friend` if your test fixture
// unavoidably contains private/protected members.
//
//     ````
//     template <typename T>
//     friend class EMST_IMPL_NAME(TestSuite, TestName);
//     ````
//
// In almost all cases, it's better _not to use this_ but to mark members of your test fixture
// `public:` instead.
#define EMST_IMPL_NAME(suite, name) ErrorModeSensitiveTest_##suite##_##name

#define EMST_IMPL_STRUCT_(suite, name)                                              \
	template <typename T>                                                           \
	struct EMST_IMPL_NAME(suite, name) {                                            \
		::navtk::ErrorMode mode;                                                    \
		T& test;                                                                    \
		::navtk::ErrorModeLock guard;                                               \
		EMST_IMPL_NAME(suite, name)                                                 \
		(::navtk::ErrorMode mode, T& test) : mode(mode), test(test), guard(mode) {} \
		void perform_test();                                                        \
	};

#define EMST_IMPL_CASE_(macro, suite, name, mode)                                     \
	macro(suite, name##_Errors##mode) {                                               \
		EMST_IMPL_NAME(suite, name)<decltype(*this)>(::navtk::ErrorMode::mode, *this) \
		    .perform_test();                                                          \
	}

#define EMST_IMPL_DEFINITION_(suite, name) \
	template <typename T>                  \
	void EMST_IMPL_NAME(suite, name)<T>::perform_test()

// Uses the given macro (one of TEST, TEST_F, etc...) to generate three unit tests, one for each
// possible ErrorMode. Each test will acquire an ErrorModeLock and then call the supplied function
// body.
//
//     ```
//     ERROR_MODE_SENSITIVE_TEST(TEST, Beer, Pretzels) {
//         cout << "code before";
//         EXPECT_HONORS_MODE(log_or_throw("example"), "example");
//         cout << "code after";
//     }
//     ```
//
// This example will create tests named `Beer.Pretzels_ErrorsOff`, `Beer.Pretzels_ErrorsLogged`, and
// `Beer.Pretzels_ErrorsFatal`. Both cout statements will run in each of the first two tests, but
// not the third (since when ErrorMode::DIE is on, log_or_throw raises an exception).
//
// The test body you supply is defined, behind the scenes, as a member function of a class called
// EMST_IMPL_NAME(suite, name), which has the following members:
//    * `mode`: The ErrorMode being tested
//    * `guard`: The ErrorModeLock instance holding that mode
//    * `test`: A reference to the individual unit test being run -- that is, an instance of a
//              subclass of your test fixture class as-generated by the `macro` you passed in.
//
// Because this macro defines a helper class, members of your test fixture are not accessible
// unqualified, but instead must be referenced as members of `test`. For example:
//
//     ```
//     class SampleTestSuite : public ::testing::Test {
//     public:
//         int three = 3;
//     };
//
//     ERROR_MODE_SENSITIVE_TEST(TEST_F, SampleTestSuite, Three) {
//         // EXPECT_EQ(three, 3); // BAD - "three" is not a member of the helper class
//         EXPECT_EQ(test.three, 3); // OK
//     }
//     ```
//
// To support this behavior, members of your fixture that need to be accessible from an
// ERROR_MODE_SENSITIVE_TEST should be declared as public, or else the test must be declared as a
// friend.
#define ERROR_MODE_SENSITIVE_TEST(macro, suite, name) \
	EMST_IMPL_STRUCT_(suite, name)                    \
	EMST_IMPL_CASE_(macro, suite, name, OFF)          \
	EMST_IMPL_CASE_(macro, suite, name, LOG)          \
	EMST_IMPL_CASE_(macro, suite, name, DIE)          \
	EMST_IMPL_DEFINITION_(suite, name)

// Expands to a comma-separated list of test names, for use in REGISTER_TYPED_TEST_SUITE_P
#define EMST_TEST_NAMES(name) name##_ErrorsOFF, name##_ErrorsLOG, name##_ErrorsDIE


#define EXPECT_UB_OR_DIE_(fatal, action, ...)                                                 \
	EXPRESSION_THROW_TESTER_(action,                                                          \
	                         ub_or_die,                                                       \
	                         VA_SECOND_(__VA_ARGS__, ::navtk::DefaultLogOrThrowException, x), \
	                         fatal,                                                           \
	                         VA_FIRST_(__VA_ARGS__, x),                                       \
	                         false)

// EXPECT_UB_OR_DIE(action, message, [optional exception class = DefaultLogOrThrowException])
// Run the given action twice, once with ::navtk::ErrorMode::DIE and once with
// ::navtk::ErrorMode::LOG. Make sure that in ErrorMode::DIE, an exception of the appropriate class
// is raised, and that in ErrorMode::LOG, a log message is printed. In the latter case, abort the
// execution of the action when the expected log message is received.
//
// Use this macro to test things that are error-mode sensitive, but which do not recover gracefully
// from invalid inputs in ErrorMode::OFF/ErrorMode::LOG. Aborting the action after the expected log
// is printed is intended to prevent the undefined behavior that would otherwise follow.
//
// This macro sets the error mode twice, and does not need to be invoked from inside an
// ERROR_MODE_SENSITIVE_TEST
//
// This macro cannot be used as an expression.
#define EXPECT_UB_OR_DIE(action, ...) EXPECT_UB_OR_DIE_(false, action, __VA_ARGS__)

// EXPECT_UB_OR_DIE, but abort the test on failure.
#define ASSERT_UB_OR_DIE(action, ...) EXPECT_UB_OR_DIE_(true, action, __VA_ARGS__)
