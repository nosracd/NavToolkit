#include <navtk/utils/data.hpp>

#include <algorithm>
#include <cctype>
#include <cstdlib>
#include <functional>
#include <regex>

// Some unixes (MacOS in particular) don't reliably export $HOME, but do expose an API to let us
// read the passwd file.
#if __has_include(<pwd.h>)
#	include <pwd.h>
#	include <unistd.h>
#	define NAVTK_HAVE_PWD
#endif

// Conditional include generated by meson containing #defines for default paths.
#if __has_include("navtk_meson_config.h")
#	include "navtk_meson_config.h"
#endif

// GNU userlands have something called secure_getenv, which we should use if we can.
#ifdef _GNU_SOURCE
#	define GETENV secure_getenv
#else
#	define GETENV getenv
#endif

// Windows uses the wrong slash
#ifdef _WIN32
#	define DIR_SLASH "\\"
#	define PATH_DELIMITER ';'
#else
#	define DIR_SLASH "/"
#	define PATH_DELIMITER ':'
#endif

using std::function;
using std::ifstream;
using std::regex;
using std::shared_ptr;
using std::string;
using std::vector;

namespace navtk {
namespace utils {

// Using a ::detail namespace here instead of an anonymous namespace for all these helper functions
// so that I can forward-declare them in unit tests. See data_tests.cpp for a more thorough
// discussion of why.
namespace detail {

// Return a std::string of the requested environment variable. Empty string if unset.
string getenv_str(const string& key) {
	auto raw = GETENV(key.c_str());
	return nullptr == raw ? "" : raw;
}

// Get the current user's home directory based on environment variables, or an empty string if it
// cannot be determined.
string home_folder() {
#ifdef _WIN32
	// On Windows the home folder is given by the environment var %USERPROFILE% most of the time,
	// but occasionally instead it's %HOMEDRIVE%%HOMEPATH%. Sources online don't seem to explain
	// when/why %USERPROFILE% would be unset but I'm taking their word for it.
	char* userprofile = GETENV("USERPROFILE");
	if (nullptr != userprofile) return userprofile;
	char* homedrive = GETENV("HOMEDRIVE");
	char* homepath  = GETENV("HOMEPATH");
	if (nullptr != homedrive && nullptr != homepath) {
		string out = homedrive;
		out += homepath;
		return out;
	}
#else
	// Most unixes set $HOME. If $HOME is missing but we have POSIX headers, we might be able to
	// read the passwd entry for the current process's UID.
	char* home = GETENV("HOME");
#	ifdef NAVTK_HAVE_PWD
	if (nullptr == home) {
		auto passwd_entry = getpwuid(getuid());
		if (nullptr != passwd_entry) home = passwd_entry->pw_dir;
	}
#	endif
	if (nullptr != home) return home;
#endif
	return "";
}

// No need to constantly reread this over and over.
static const string HOME = home_folder();


// Compare at most `limit` characters from `a` and `b` and return true only if they differ only by
// case.
bool case_insensitive_equal(const string& a, const string& b, size_t limit = -1) {
	if (std::min(limit, a.length()) != std::min(limit, b.length())) return false;
	auto b_itr = b.begin();
	for (const auto& a_chr : a) {
		if (!limit--) return true;
		if (toupper(a_chr) != toupper(*(b_itr++))) return false;
	}
	return true;
}


// When the "haystack" begins with the "needle", return the length of the needle. Otherwise, 0.
size_t starts_with(const string& haystack, const string& needle, bool case_sense = true) {
	size_t needle_len = needle.length();
	size_t limit      = std::min(haystack.length(), needle_len);
	if (limit < needle_len) {
		// the "haystack" isn't long enough to contain the "needle"
		return 0;
	}
	if (case_sense) {
		auto h_itr = haystack.begin();
		for (const auto& n_chr : needle)
			if (n_chr != *(h_itr++)) return 0;
	} else if (!case_insensitive_equal(needle, haystack, limit))
		return 0;
	return limit;
}


// Given a path that begins with `~`, `$HOME`, or `%userprofile%`, return a path rooted at the
// user's home directory.
//
// Absolute and relative paths that do not reference the home folder are returned unmodified.
//
// If the home folder cannot be determined, but the input path references it, an empty string is
// returned.
//
// Inspired by Python`s `os.path.expanduser`.
string expand_user(const string& path) {
	size_t substr_idx;

	if (path == "~" || path == "$HOME" || case_insensitive_equal(path, "%userprofile%"))
		return HOME;

	if ((substr_idx = starts_with(path, "~" DIR_SLASH)) ||
	    (substr_idx = starts_with(path, "$HOME" DIR_SLASH)) ||
	    (substr_idx = starts_with(path, "%userprofile%" DIR_SLASH, false))) {
		// If we can't detect the home folder, then we can't expand this path correctly, so return
		// an empty string instead.
		if (HOME.empty()) return "";

		// Compose a full path using the home folder, a dir slash, and the part of the input path
		// occurring after the PREFIX match. We can't use regex_replace here because it supports
		// special replacement syntaxes, such as back-references. It would be possible for a
		// malformed $HOME to cause an exception.
		return HOME + DIR_SLASH + path.substr(substr_idx);
	}

	// The path doesn't start with ~, $HOME, or %UserProfile% so return it unmodified
	return path;
}

// Split the given string based on the given delimiter, omitting any empty substrings.
vector<string> split_paths(const string& paths, char delim = PATH_DELIMITER) {
	vector<string> out;
	if (!paths.empty()) {
		size_t last_pos = 0;
		size_t pos      = 0;
		while ((pos = paths.find(delim, pos)) != string::npos) {
			if (pos != last_pos) out.emplace_back(paths.substr(last_pos, pos - last_pos));
			// Start subsequent finds after the end of the current pos (otherwise an empty substring
			// causes an infinite loop)
			last_pos = ++pos;
		}

		// Because of the ++pos above, last_pos will be equal to length if the last character in the
		// string is a delimiter.
		if (last_pos < paths.length()) out.emplace_back(expand_user(paths.substr(last_pos)));
	}
	return out;
}

// The user may set $NAVTK_DATA_DIR if they want to explicitly point us at a search folder
static const vector<string> NAVTK_DATA_DIR = split_paths(getenv_str(NAVTK_DATA_DIR_ENV_VAR));

// If a Python virtual environment has been activated, then VIRTUAL_ENV should be set to the
// directory containing it.
static const string VIRTUAL_ENVIRONMENT_DATA_DIR = getenv_str("VIRTUAL_ENV");

// Helper function for converting possibly-unset macros (that should be provided by meson via
// navtk_meson_config.h) to a vector of search paths. env_key is the name of the environment
// variable that might contain a PATH_DELIMITER-separated list of paths to search. If that
// environment variable is unset, use the "fallback" value instead.
//
// OS_DATA_HOME and OS_DATA_DIRS below use brace init to pass in values that may or may not have
// been #defined. When the macro is set, the compiler sees { MACRO } -> { "value" }, which creates
// an std::string from the literal. When the macro is unset, it sees {} which creates an empty
// string.
vector<string> env_path_or_default(const string& env_key, const string& fallback) {
	if (!env_key.empty()) {
		auto from_env = split_paths(getenv_str(env_key));
		if (!from_env.empty()) return from_env;
	}
	return split_paths(fallback);
}

// This is $XDG_DATA_HOME on Linux and %APPDATA% on Windows
static const vector<string> OS_DATA_HOME = env_path_or_default(
    {
#ifdef NAVTK_OS_DATA_HOME_ENV_VAR
        NAVTK_OS_DATA_HOME_ENV_VAR
#endif
    },
    {
#ifdef NAVTK_OS_DATA_HOME_DEFAULT
        NAVTK_OS_DATA_HOME_DEFAULT
#endif
    });

// This is $XDG_DATA_DIRS on Linux and %PROGRAMDATA% on Windows
static const vector<string> OS_DATA_DIRS = env_path_or_default(
    {
#ifdef NAVTK_OS_DATA_DIRS_ENV_VAR
        NAVTK_OS_DATA_DIRS_ENV_VAR
#endif
    },
    {
#ifdef NAVTK_OS_DATA_DIRS_DEFAULT
        NAVTK_OS_DATA_DIRS_DEFAULT
#endif
    });

// Convert a human-readable file label to an environment variable key name, stripping out any
// invalid characters and adding a PREFIX & SUFFIX.
static const regex ENV_KEY_UNSAFE_CHARS{"[^a-zA-Z0-9]+"};
string label_to_env_key(const string& label) {
	auto out = std::regex_replace(label, ENV_KEY_UNSAFE_CHARS, "_");
	for (auto& chr : out) chr = std::toupper(chr);

	constexpr auto PREFIX = NAVTK_DATA_FILE_ENV_VAR_PREFIX;
	constexpr auto SUFFIX = NAVTK_DATA_FILE_ENV_VAR_SUFFIX;
	return PREFIX + out + SUFFIX;
}

// Return true if the given string looks like an absolute path on the current platform.
#ifdef _WIN32
static const regex ABSPATH_PATTERN{"^[a-zA-Z]:\\\\"};
bool is_absolute_path(const string& path) { return std::regex_search(path, ABSPATH_PATTERN); }
#else
bool is_absolute_path(const string& path) { return !path.empty() && path[0] == '/'; }
#endif

// Combine two paths. Basically, os.path.join() from python.
string join_paths(const string& left, const string& right) {
	if (right.empty()) return left;
	if (left.empty() || is_absolute_path(right)) return right;
	if (left.back() == DIR_SLASH[0]) return left + right;
	return left + DIR_SLASH + right;
}

// Add the given path to the list of places searched, and call try_path with a file called basename
// in that folder.
bool try_data_dir(vector<string>& places_searched,
                  const string& data_dir_path,
                  const string& basename,
                  const function<bool(const string&)>& try_path) {
	auto expanded = data_dir_path;
	if (expanded.empty()) return false;
	places_searched.emplace_back(expanded);
	return try_path(join_paths(expanded, basename));
}

// try_data_dir but with the navtk subfolder of the path provided
bool try_os_data_dir(vector<string>& places_searched,
                     const string& data_dir_path,
                     const string& basename,
                     const function<bool(const string&)>& try_path) {
	return try_data_dir(places_searched,
	                    join_paths(data_dir_path, NAVTK_OS_DATA_DIR_SUBFOLDER_NAME),
	                    basename,
	                    try_path);
}


void visit_possible_file_paths(ErrorMode error_mode,
                               const string& label,
                               const string& basename,
                               function<bool(const string&)> try_path) {

	string file_specific_env_key = label_to_env_key(label);

	// First, check if the file-specific environment variable has been set to something non-empty.
	// If it has, the correct file must be at that location and we should refuse to check any other
	// locations.
	{
		string raw_file_specific_env = getenv_str(file_specific_env_key);
		string file_specific_env     = expand_user(raw_file_specific_env);
		if (!file_specific_env.empty()) {
			if (!try_path(file_specific_env))
				log_or_throw(error_mode,
				             "Unable to open {} file `{}` specified by environment variable {}",
				             label,
				             file_specific_env,
				             file_specific_env_key);
			return;
		} else if (!raw_file_specific_env.empty()) {
			log_or_throw(error_mode,
			             "Unable to find {} file `{}` specified by environment variable {} because "
			             "the path refers to your home folder, which could not be found.",
			             label,
			             raw_file_specific_env,
			             file_specific_env_key);
			return;
		}
	}

	// Keep track of everywhere we've looked for our data file, so that if we don't find it we can
	// include that information when we error out.
	vector<string> places_searched;

	// Now, try_path for each of the places listed in the docstring for open_data_file

	// Check for a NAVTK_DATA_DIR environment variable and scan places it suggests
	for (const auto& possible_path : NAVTK_DATA_DIR)
		if (try_data_dir(places_searched, possible_path, basename, try_path)) return;

	// User data folders next
	for (const auto& possible_path : OS_DATA_HOME)
		if (try_os_data_dir(places_searched, possible_path, basename, try_path)) return;

	// Global data folders
	for (const auto& possible_path : OS_DATA_DIRS)
		if (try_os_data_dir(places_searched, possible_path, basename, try_path)) return;

#ifdef NAVTK_DATA_DIR_PREFIX
	// Meson's -Ddatadir option, will point to something like /usr/local/share
	if (try_os_data_dir(places_searched, NAVTK_DATA_DIR_PREFIX, basename, try_path)) return;
#endif

	// Current working directory
	if (try_data_dir(places_searched, ".", basename, try_path)) return;

	// Python virtual environment
	if (try_os_data_dir(places_searched, VIRTUAL_ENVIRONMENT_DATA_DIR, basename, try_path)) return;

	log_or_throw(error_mode,
	             "Cannot open {} file `{}` from any of the following locations {}. Consider "
	             "setting the environment variable {}.",
	             label,
	             basename,
	             places_searched,
	             file_specific_env_key);
}

}  // namespace detail


shared_ptr<ifstream> open_data_file(ErrorMode error_mode,
                                    const string& label,
                                    const string& basename,
                                    std::ios_base::openmode mode) {
	shared_ptr<ifstream> out = nullptr;
	detail::visit_possible_file_paths(error_mode, label, basename, [&](const string& path) -> bool {
		out = std::make_shared<ifstream>(path, mode);
		return out->is_open();
	});
	return (nullptr != out && out->is_open()) ? out : nullptr;
}

shared_ptr<ifstream> open_data_file(const string& label,
                                    const string& basename,
                                    std::ios_base::openmode mode) {
	return open_data_file(get_global_error_mode(), label, basename, mode);
}

}  // namespace utils
}  // namespace navtk
